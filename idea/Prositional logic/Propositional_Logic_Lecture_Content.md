# Propositional Logic - Lecture Content Guide

**Course:** Introduction to Artificial Intelligence  
**Topic:** Propositional Logic (Logic M·ªánh ƒê·ªÅ)  
**Reference:** AIMA Chapters 7-8, [YouTube Tutorial](https://www.youtube.com/watch?v=ONxr7v3HaKo&t=1894s)  
**Prepared for:** Week 9 Lecture

---

## üìã Lecture Overview

### Learning Objectives
By the end of this lecture, students should be able to:
1. Understand the syntax and semantics of propositional logic
2. Represent knowledge using logical sentences
3. Apply inference rules to derive new knowledge
4. Use truth tables and logical equivalences
5. Understand model checking and theorem proving
6. Apply resolution and CNF conversion

### Time Allocation (2-hour lecture)
- Introduction & Motivation: 15 minutes
- Syntax & Semantics: 25 minutes
- Logical Connectives & Truth Tables: 20 minutes
- Logical Equivalences: 20 minutes
- Inference Rules: 25 minutes
- Resolution & CNF: 20 minutes
- Practical Examples: 15 minutes

---

## üéØ Part 1: Introduction to Logic in AI

### Slide 1: Title Slide
**Propositional Logic (Logic M·ªánh ƒê·ªÅ)**
- Introduction to Artificial Intelligence
- Week 9
- Dr. Trong-Nghia Nguyen

### Slide 2: Why Logic in AI?
**The Role of Logic:**
- Knowledge representation
- Reasoning and inference
- Decision making
- Verification and validation

**Real-world Applications:**
- Expert systems
- Automated reasoning
- Database query optimization
- Circuit design and verification
- Natural language understanding

### Slide 3: Knowledge-Based Agents
```
Knowledge Base (KB)
    ‚Üì
TELL: Add new sentences
ASK: Query what is known
    ‚Üì
Inference Engine
```

**Components:**
- **Knowledge Base:** Collection of sentences in formal language
- **Inference Engine:** Derives new sentences from existing ones
- **TELL:** Add facts to KB
- **ASK:** Query KB for conclusions

### Slide 4: From Search to Logic
**Search Problems vs. Logic:**
| Search | Logic |
|--------|-------|
| States and actions | Sentences and inference |
| Path finding | Proof finding |
| Goal state | Query satisfaction |
| Heuristics | Inference rules |

---

## üìù Part 2: Syntax of Propositional Logic

### Slide 5: What is a Proposition?
**Definition:**
A proposition is a declarative sentence that is either TRUE or FALSE (but not both).

**Examples of Propositions:**
‚úÖ "It is raining" (P)
‚úÖ "2 + 2 = 4" (Q)
‚úÖ "The student passed the exam" (R)

**Not Propositions:**
‚ùå "What time is it?" (question)
‚ùå "Close the door!" (command)
‚ùå "x + 1 = 5" (contains variable, not declarative)

### Slide 6: Atomic and Compound Propositions
**Atomic Propositions (M·ªánh ƒë·ªÅ ƒë∆°n):**
- Single propositional symbols: P, Q, R, S, ...
- Cannot be broken down further
- Examples: "It is raining", "I am hungry"

**Compound Propositions (M·ªánh ƒë·ªÅ ph·ª©c):**
- Formed by combining atomic propositions using logical connectives
- Examples: "It is raining AND I am hungry"

### Slide 7: Logical Connectives (Ph√©p to√°n logic)
**Five Main Connectives:**

1. **Negation (NOT, Ph·ªß ƒë·ªãnh):** ¬¨P or ~P
2. **Conjunction (AND, H·ªôi):** P ‚àß Q
3. **Disjunction (OR, Tuy·ªÉn):** P ‚à® Q
4. **Implication (IF-THEN, K√©o theo):** P ‚Üí Q or P ‚áí Q
5. **Biconditional (IF AND ONLY IF, T∆∞∆°ng ƒë∆∞∆°ng):** P ‚Üî Q or P ‚áî Q

### Slide 8: Syntax - BNF Grammar
**Backus-Naur Form:**
```
Sentence ‚Üí AtomicSentence | ComplexSentence

AtomicSentence ‚Üí True | False | P | Q | R | ...

ComplexSentence ‚Üí (Sentence)
                | ¬¨Sentence
                | Sentence ‚àß Sentence
                | Sentence ‚à® Sentence
                | Sentence ‚Üí Sentence
                | Sentence ‚Üî Sentence
```

**Operator Precedence (highest to lowest):**
1. ¬¨ (Negation)
2. ‚àß (Conjunction)
3. ‚à® (Disjunction)
4. ‚Üí (Implication)
5. ‚Üî (Biconditional)

---

## üîç Part 3: Semantics of Propositional Logic

### Slide 9: Truth Values and Models
**Semantics defines:**
- Truth values: TRUE (T, 1) or FALSE (F, 0)
- How to determine truth value of any sentence

**Model:**
A model assigns truth values to all propositional symbols.

**Example:**
If we have P, Q, R, a model might be:
- m = {P: True, Q: False, R: True}

**Number of Models:**
- n propositional symbols ‚Üí 2‚Åø possible models

### Slide 10: Truth Table - Negation (¬¨)
**NOT Operator:**

| P | ¬¨P |
|---|-----|
| T | F   |
| F | T   |

**Properties:**
- ¬¨¬¨P ‚â° P (Double negation)
- Reverses truth value

### Slide 11: Truth Table - Conjunction (‚àß)
**AND Operator:**

| P | Q | P ‚àß Q |
|---|---|-------|
| T | T | **T** |
| T | F | F     |
| F | T | F     |
| F | F | F     |

**Meaning:** True only when BOTH operands are true

**Example:**
- "It is raining AND I have an umbrella"

### Slide 12: Truth Table - Disjunction (‚à®)
**OR Operator (Inclusive):**

| P | Q | P ‚à® Q |
|---|---|-------|
| T | T | **T** |
| T | F | **T** |
| F | T | **T** |
| F | F | F     |

**Meaning:** True when AT LEAST ONE operand is true

**Example:**
- "I will take the bus OR the train"

### Slide 13: Truth Table - Implication (‚Üí)
**IF-THEN Operator:**

| P | Q | P ‚Üí Q |
|---|---|-------|
| T | T | **T** |
| T | F | F     |
| F | T | **T** |
| F | F | **T** |

**Meaning:**
- P is the **premise/antecedent** (gi·∫£ thi·∫øt)
- Q is the **conclusion/consequent** (k·∫øt lu·∫≠n)
- False only when P is true and Q is false

**Important:** P ‚Üí Q ‚â° ¬¨P ‚à® Q

**Example:**
- "If it rains, then the ground is wet"

### Slide 14: Understanding Implication
**Common Confusion:**
Why is "False ‚Üí True" evaluated as True?

**Explanation:**
- Implication is a promise
- "If P then Q" is broken only when P is true but Q is false
- If P is false, the promise is vacuously true (kh√¥ng b·ªã vi ph·∫°m)

**Example:**
- "If I win the lottery, I will buy you a car"
- If I don't win (P is false), I didn't break my promise regardless of whether I buy you a car

### Slide 15: Truth Table - Biconditional (‚Üî)
**IF AND ONLY IF Operator:**

| P | Q | P ‚Üî Q |
|---|---|-------|
| T | T | **T** |
| T | F | F     |
| F | T | F     |
| F | F | **T** |

**Meaning:** True when P and Q have the SAME truth value

**Equivalence:** P ‚Üî Q ‚â° (P ‚Üí Q) ‚àß (Q ‚Üí P)

**Example:**
- "You pass the course if and only if you score ‚â• 50"

### Slide 16: Complex Example
**Sentence:** (P ‚à® Q) ‚Üí (R ‚àß ¬¨S)

**Truth Table:**
| P | Q | R | S | P‚à®Q | ¬¨S | R‚àß¬¨S | (P‚à®Q)‚Üí(R‚àß¬¨S) |
|---|---|---|---|-----|----|----- |--------------|
| T | T | T | T | T   | F  | F    | F            |
| T | T | T | F | T   | T  | T    | T            |
| T | F | T | T | T   | F  | F    | F            |
| ... (show 4-5 rows as example)

---

## üí° Part 4: Logical Equivalences

### Slide 17: Logical Equivalence
**Definition:**
Two sentences Œ± and Œ≤ are logically equivalent (Œ± ‚â° Œ≤) if they have the same truth value in every model.

**Notation:** Œ± ‚â° Œ≤ or Œ± ‚áî Œ≤

### Slide 18: Important Equivalences - Part 1
**Fundamental Laws:**

1. **Double Negation:**
   - ¬¨(¬¨P) ‚â° P

2. **Commutative Laws:**
   - P ‚àß Q ‚â° Q ‚àß P
   - P ‚à® Q ‚â° Q ‚à® P

3. **Associative Laws:**
   - (P ‚àß Q) ‚àß R ‚â° P ‚àß (Q ‚àß R)
   - (P ‚à® Q) ‚à® R ‚â° P ‚à® (Q ‚à® R)

4. **Distributive Laws:**
   - P ‚àß (Q ‚à® R) ‚â° (P ‚àß Q) ‚à® (P ‚àß R)
   - P ‚à® (Q ‚àß R) ‚â° (P ‚à® Q) ‚àß (P ‚à® R)

### Slide 19: Important Equivalences - Part 2
**De Morgan's Laws (Lu·∫≠t De Morgan):**
1. ¬¨(P ‚àß Q) ‚â° ¬¨P ‚à® ¬¨Q
2. ¬¨(P ‚à® Q) ‚â° ¬¨P ‚àß ¬¨Q

**Example:**
- "It is not the case that it is raining AND cold"
- ‚â° "It is not raining OR it is not cold"

**Memory Trick:** "Break the line, change the sign"

### Slide 20: Implication Equivalences
**Key Equivalences for Implication:**

1. **Implication Definition:**
   - P ‚Üí Q ‚â° ¬¨P ‚à® Q

2. **Contrapositive:**
   - P ‚Üí Q ‚â° ¬¨Q ‚Üí ¬¨P

3. **Biconditional:**
   - P ‚Üî Q ‚â° (P ‚Üí Q) ‚àß (Q ‚Üí P)
   - P ‚Üî Q ‚â° (P ‚àß Q) ‚à® (¬¨P ‚àß ¬¨Q)

### Slide 21: Identity and Domination Laws
**Identity Laws:**
- P ‚àß True ‚â° P
- P ‚à® False ‚â° P

**Domination Laws:**
- P ‚àß False ‚â° False
- P ‚à® True ‚â° True

**Idempotent Laws:**
- P ‚àß P ‚â° P
- P ‚à® P ‚â° P

**Absorption Laws:**
- P ‚àß (P ‚à® Q) ‚â° P
- P ‚à® (P ‚àß Q) ‚â° P

---

## üî¨ Part 5: Inference and Reasoning

### Slide 22: Logical Inference
**Key Concepts:**

**Entailment (K√©o theo logic):** KB ‚ä® Œ±
- Knowledge Base KB entails sentence Œ±
- In every model where KB is true, Œ± is also true
- Œ± is a logical consequence of KB

**Derivation (Suy di·ªÖn):** KB ‚ä¢ Œ±
- Œ± can be derived from KB using inference rules

**Sound and Complete:**
- **Sound:** If KB ‚ä¢ Œ± then KB ‚ä® Œ± (derives only true things)
- **Complete:** If KB ‚ä® Œ± then KB ‚ä¢ Œ± (can derive everything true)

### Slide 23: Model Checking
**Algorithm:**
1. Enumerate all possible models
2. Check if Œ± is true in all models where KB is true
3. If yes, then KB ‚ä® Œ±

**Example:**
- KB = {P ‚Üí Q, P}
- Query: Does KB ‚ä® Q?

| P | Q | P‚ÜíQ | KB | Q |
|---|---|-----|----|---|
| T | T | T   | T  | T |
| T | F | F   | F  | - |
| F | T | T   | -  | - |
| F | F | T   | -  | - |

**Result:** In the only model where KB is true (P=T, Q=T), Q is also true. Therefore, KB ‚ä® Q ‚úì

### Slide 24: Inference Rules - Modus Ponens
**Most Important Rule:**

**Modus Ponens (Quy t·∫Øc t√°ch):**
```
    P ‚Üí Q
    P
    ------
    Q
```

**Example:**
- "If it rains, the ground is wet"
- "It is raining"
- **Therefore:** "The ground is wet"

**Application:** Forward chaining

### Slide 25: Inference Rules - Modus Tollens
**Modus Tollens (Ph·∫£n ch·ª©ng):**
```
    P ‚Üí Q
    ¬¨Q
    ------
    ¬¨P
```

**Example:**
- "If it rains, the ground is wet"
- "The ground is not wet"
- **Therefore:** "It did not rain"

**Contrapositive form:** Uses P ‚Üí Q ‚â° ¬¨Q ‚Üí ¬¨P

### Slide 26: More Inference Rules
**And-Elimination (Gi·∫£n l∆∞·ª£c h·ªôi):**
```
    P ‚àß Q
    ------
    P
```

**And-Introduction (T·ªïng h·ª£p h·ªôi):**
```
    P
    Q
    ------
    P ‚àß Q
```

**Or-Introduction (T·ªïng h·ª£p tuy·ªÉn):**
```
    P
    ------
    P ‚à® Q
```

**Double-Negation Elimination:**
```
    ¬¨¬¨P
    ------
    P
```

### Slide 27: Resolution Rule
**The Universal Inference Rule:**

**Resolution:**
```
    P ‚à® Q
    ¬¨P ‚à® R
    --------
    Q ‚à® R
```

**Why Important:**
- Single rule sufficient for complete inference
- Basis for automated theorem proving
- Works with clauses in CNF

**Special Cases:**

**Unit Resolution:**
```
    P ‚à® Q
    ¬¨P
    ------
    Q
```

**Binary Resolution:**
```
    P
    ¬¨P
    ------
    False (contradiction)
```

---

## üõ†Ô∏è Part 6: Normal Forms and Resolution

### Slide 28: Conjunctive Normal Form (CNF)
**Definition:**
A sentence in CNF is a conjunction of clauses, where each clause is a disjunction of literals.

**Form:** (l‚ÇÅ ‚à® l‚ÇÇ ‚à® ... ‚à® l‚Çò) ‚àß (l‚Çô ‚à® ... ‚à® l‚Çö) ‚àß ...

**Literal:** Atomic proposition or its negation (P or ¬¨P)
**Clause:** Disjunction of literals

**Examples:**
- CNF: (P ‚à® Q) ‚àß (¬¨P ‚à® R ‚à® S) ‚àß (¬¨Q)
- Not CNF: P ‚à® (Q ‚àß R)

### Slide 29: Converting to CNF
**Steps to Convert any Sentence to CNF:**

1. **Eliminate biconditionals:**
   - Replace (P ‚Üî Q) with (P ‚Üí Q) ‚àß (Q ‚Üí P)

2. **Eliminate implications:**
   - Replace (P ‚Üí Q) with (¬¨P ‚à® Q)

3. **Move ¬¨ inward (De Morgan's):**
   - Replace ¬¨(P ‚àß Q) with (¬¨P ‚à® ¬¨Q)
   - Replace ¬¨(P ‚à® Q) with (¬¨P ‚àß ¬¨Q)
   - Replace ¬¨¬¨P with P

4. **Distribute ‚à® over ‚àß:**
   - Replace P ‚à® (Q ‚àß R) with (P ‚à® Q) ‚àß (P ‚à® R)

### Slide 30: CNF Conversion Example
**Convert:** (P ‚Üí Q) ‚Üî (¬¨Q ‚Üí ¬¨P)

**Step 1 - Eliminate ‚Üî:**
- ((P ‚Üí Q) ‚Üí (¬¨Q ‚Üí ¬¨P)) ‚àß ((¬¨Q ‚Üí ¬¨P) ‚Üí (P ‚Üí Q))

**Step 2 - Eliminate ‚Üí:**
- (¬¨(¬¨P ‚à® Q) ‚à® (¬¨¬¨Q ‚à® ¬¨P)) ‚àß (¬¨(¬¨¬¨Q ‚à® ¬¨P) ‚à® (¬¨P ‚à® Q))

**Step 3 - Move ¬¨ inward:**
- ((P ‚àß ¬¨Q) ‚à® (Q ‚à® ¬¨P)) ‚àß ((¬¨Q ‚àß P) ‚à® (¬¨P ‚à® Q))

**Step 4 - Distribute:**
- (P ‚à® Q ‚à® ¬¨P) ‚àß (¬¨Q ‚à® Q ‚à® ¬¨P) ‚àß (¬¨Q ‚à® ¬¨P ‚à® Q) ‚àß (P ‚à® ¬¨P ‚à® Q)

**Simplify:** True (tautology)

### Slide 31: Resolution Algorithm
**Proof by Contradiction:**

**To prove KB ‚ä® Œ±:**
1. Convert KB ‚àß ¬¨Œ± to CNF
2. Apply resolution rule repeatedly
3. If derive empty clause (‚ä•), then KB ‚ä® Œ±
4. If no new clauses can be derived, then KB ‚ä≠ Œ±

**Pseudocode:**
```
function PL-RESOLUTION(KB, Œ±):
    clauses = CNF(KB ‚àß ¬¨Œ±)
    new = {}
    
    while True:
        for each pair of clauses C‚ÇÅ, C‚ÇÇ in clauses:
            resolvents = RESOLVE(C‚ÇÅ, C‚ÇÇ)
            
            if ‚ä• ‚àà resolvents:
                return True  # Proved
            
            new = new ‚à™ resolvents
        
        if new ‚äÜ clauses:
            return False  # Cannot prove
        
        clauses = clauses ‚à™ new
```

### Slide 32: Resolution Example
**Given:**
- KB: {P ‚Üí Q, Q ‚Üí R, P}
- Prove: R

**Step 1 - Add negation of goal:**
- KB ‚à™ {¬¨R}

**Step 2 - Convert to CNF:**
- {¬¨P ‚à® Q, ¬¨Q ‚à® R, P, ¬¨R}

**Step 3 - Apply resolution:**
```
1. ¬¨P ‚à® Q      (KB)
2. P            (KB)
3. Q            (Resolve 1,2)
4. ¬¨Q ‚à® R       (KB)
5. R            (Resolve 3,4)
6. ¬¨R           (negated goal)
7. ‚ä•            (Resolve 5,6) ‚úì
```

**Conclusion:** Contradiction found, therefore KB ‚ä® R

---

## üéì Part 7: Practical Applications

### Slide 33: Wumpus World Example
**Environment:**
- Grid world with pits and Wumpus (monster)
- Agent can perceive: Breeze (near pit), Stench (near Wumpus)
- Goal: Find gold, avoid dangers

**Knowledge Representation:**
- P‚ÇÅ‚ÇÅ: There is a pit in [1,1]
- W‚ÇÅ‚ÇÉ: There is a Wumpus in [1,3]
- B‚ÇÇ‚ÇÅ: Agent feels breeze in [2,1]

**Rules:**
- B‚ÇÅ‚ÇÅ ‚Üî (P‚ÇÅ‚ÇÇ ‚à® P‚ÇÇ‚ÇÅ)
- S‚ÇÅ‚ÇÅ ‚Üî (W‚ÇÅ‚ÇÇ ‚à® W‚ÇÇ‚ÇÅ)

**Inference:**
If ¬¨B‚ÇÅ‚ÇÅ (no breeze), then ¬¨P‚ÇÅ‚ÇÇ ‚àß ¬¨P‚ÇÇ‚ÇÅ (no adjacent pits)

### Slide 34: Circuit Verification
**Application in Hardware:**

**Half Adder Circuit:**
```
Inputs: A, B
Outputs: Sum, Carry

Sum = (A ‚à® B) ‚àß ¬¨(A ‚àß B)  # XOR
Carry = A ‚àß B
```

**Verification:**
- Prove: If A=1 and B=1, then Carry=1
- Use resolution to verify circuit properties

### Slide 35: Puzzle Solving - Sudoku
**Represent Sudoku Rules:**

**Variables:**
- P_{i,j,k}: Cell (i,j) contains number k

**Constraints:**
1. **Each cell has exactly one number:**
   - (P_{i,j,1} ‚à® P_{i,j,2} ‚à® ... ‚à® P_{i,j,9})
   - ¬¨P_{i,j,k} ‚à® ¬¨P_{i,j,l} for k ‚â† l

2. **Each row has each number once:**
   - Similar constraints for rows, columns, boxes

**Solve:** Use SAT solver (resolution-based)

### Slide 36: Expert Systems
**Medical Diagnosis Example:**

**Rules:**
1. If (Fever ‚àß Cough) ‚Üí Flu
2. If (Fever ‚àß Rash) ‚Üí Measles
3. If Flu ‚Üí Prescribe_Rest
4. If Measles ‚Üí Prescribe_Vaccine

**Facts (from patient):**
- Fever = True
- Cough = True

**Inference:**
- Using Modus Ponens: Flu = True
- Using Modus Ponens: Prescribe_Rest = True

---

## üìä Part 8: Limitations and Extensions

### Slide 37: Limitations of Propositional Logic
**Cannot Express:**

1. **Generalizations:**
   - "All students who study hard pass the exam"
   - Need: ‚àÄx (Student(x) ‚àß StudyHard(x) ‚Üí Pass(x))

2. **Relationships:**
   - "John is taller than Mary"
   - Need: Taller(John, Mary)

3. **Object properties:**
   - "Every dog has an owner"
   - Need quantifiers and predicates

**Solution:** First-Order Logic (Next lecture)

### Slide 38: Computational Complexity
**Problems:**

**Satisfiability (SAT):**
- Is there a model that satisfies a sentence?
- NP-Complete problem
- Exponential worst-case: 2‚Åø models for n symbols

**Optimizations:**
1. DPLL algorithm (Davis-Putnam-Logemann-Loveland)
2. Conflict-driven clause learning
3. Modern SAT solvers (very efficient in practice)

**Applications:**
- Model checking
- Planning
- Scheduling
- Verification

### Slide 39: From Propositional to First-Order Logic
**Extensions Needed:**

| Propositional Logic | First-Order Logic |
|---------------------|-------------------|
| True/False values | Objects, relations |
| Propositions | Predicates |
| Connectives | Connectives + Quantifiers |
| Limited expressiveness | Rich expressiveness |

**Preview of FOL:**
- Variables: x, y, z
- Quantifiers: ‚àÄ (for all), ‚àÉ (there exists)
- Functions: father(John)
- Predicates: Loves(John, Mary)

---

## üß™ Part 9: Hands-on Exercises

### Slide 40: Exercise 1 - Truth Tables
**Problem:**
Construct truth table for: (P ‚Üí Q) ‚àß (Q ‚Üí R) ‚Üí (P ‚Üí R)

**Solution:**
| P | Q | R | P‚ÜíQ | Q‚ÜíR | P‚ÜíR | (P‚ÜíQ)‚àß(Q‚ÜíR) | Result |
|---|---|---|-----|-----|-----|-------------|--------|
| T | T | T | T   | T   | T   | T           | T      |
| T | T | F | T   | F   | F   | F           | T      |
| ... (complete table)

**Conclusion:** Tautology (always true) - Transitivity of implication

### Slide 41: Exercise 2 - Logical Equivalence
**Prove:** ¬¨(P ‚Üí Q) ‚â° P ‚àß ¬¨Q

**Solution:**
```
¬¨(P ‚Üí Q)
‚â° ¬¨(¬¨P ‚à® Q)         [Implication definition]
‚â° ¬¨¬¨P ‚àß ¬¨Q          [De Morgan's law]
‚â° P ‚àß ¬¨Q            [Double negation]
```

### Slide 42: Exercise 3 - CNF Conversion
**Convert to CNF:** (P ‚à® Q) ‚Üí (P ‚àß R)

**Solution:**
```
(P ‚à® Q) ‚Üí (P ‚àß R)
‚â° ¬¨(P ‚à® Q) ‚à® (P ‚àß R)           [Eliminate ‚Üí]
‚â° (¬¨P ‚àß ¬¨Q) ‚à® (P ‚àß R)           [De Morgan's]
‚â° ((¬¨P ‚àß ¬¨Q) ‚à® P) ‚àß ((¬¨P ‚àß ¬¨Q) ‚à® R)    [Distribute ‚à®]
‚â° ((¬¨P ‚à® P) ‚àß (¬¨Q ‚à® P)) ‚àß ((¬¨P ‚à® R) ‚àß (¬¨Q ‚à® R))
‚â° (True ‚àß (¬¨Q ‚à® P)) ‚àß ((¬¨P ‚à® R) ‚àß (¬¨Q ‚à® R))
‚â° (¬¨Q ‚à® P) ‚àß (¬¨P ‚à® R) ‚àß (¬¨Q ‚à® R)
```

**Final CNF:** (P ‚à® ¬¨Q) ‚àß (R ‚à® ¬¨P) ‚àß (R ‚à® ¬¨Q)

### Slide 43: Exercise 4 - Resolution Proof
**Given KB:**
1. Smoke ‚Üí Fire
2. Smoke
3. Fire ‚Üí Alarm

**Prove:** Alarm

**Solution in CNF:**
1. ¬¨Smoke ‚à® Fire
2. Smoke
3. ¬¨Fire ‚à® Alarm
4. ¬¨Alarm (negated goal)

**Resolution steps:**
```
5. Fire            (Resolve 1,2)
6. Alarm           (Resolve 3,5)
7. ‚ä•               (Resolve 4,6) ‚úì
```

### Slide 44: Exercise 5 - Real-World Problem
**Scenario: Course Registration**

**Facts:**
- If student has prerequisite, can enroll in course
- John has completed Programming
- Programming is prerequisite for AI
- AI is prerequisite for Machine Learning

**Questions:**
1. Can John enroll in AI? (Yes)
2. Can John enroll in Machine Learning? (No, needs AI first)

**Formalization:**
- HasPrereq(John, Programming)
- Prereq(AI, Programming)
- Prereq(ML, AI)
- ‚àÄx,y (HasPrereq(x,y) ‚àß Prereq(z,y) ‚Üí CanEnroll(x,z))

*Note: This requires First-Order Logic (next lecture)*

---

## üéØ Part 10: Summary and Key Takeaways

### Slide 45: Key Concepts Summary
**Syntax:**
- Propositions, connectives, well-formed formulas
- Precedence: ¬¨ > ‚àß > ‚à® > ‚Üí > ‚Üî

**Semantics:**
- Truth values, models, truth tables
- Logical equivalence, tautology, contradiction

**Inference:**
- Entailment (‚ä®), derivation (‚ä¢)
- Inference rules: Modus Ponens, Resolution
- CNF conversion and resolution algorithm

### Slide 46: Important Equivalences Cheat Sheet
```
1. ¬¨¬¨P ‚â° P
2. P ‚Üí Q ‚â° ¬¨P ‚à® Q
3. P ‚Üí Q ‚â° ¬¨Q ‚Üí ¬¨P (Contrapositive)
4. ¬¨(P ‚àß Q) ‚â° ¬¨P ‚à® ¬¨Q (De Morgan's)
5. ¬¨(P ‚à® Q) ‚â° ¬¨P ‚àß ¬¨Q (De Morgan's)
6. P ‚àß (Q ‚à® R) ‚â° (P ‚àß Q) ‚à® (P ‚àß R) (Distribution)
7. P ‚à® (Q ‚àß R) ‚â° (P ‚à® Q) ‚àß (P ‚à® R) (Distribution)
```

### Slide 47: Inference Rules Summary
```
Modus Ponens:    P‚ÜíQ, P ‚ä¢ Q
Modus Tollens:   P‚ÜíQ, ¬¨Q ‚ä¢ ¬¨P
And-Elim:        P‚àßQ ‚ä¢ P
And-Intro:       P, Q ‚ä¢ P‚àßQ
Or-Intro:        P ‚ä¢ P‚à®Q
Resolution:      P‚à®Q, ¬¨P‚à®R ‚ä¢ Q‚à®R
```

### Slide 48: When to Use What?
**Truth Tables:**
- Small number of propositions (‚â§ 5)
- Checking validity/satisfiability
- Understanding operator behavior

**Logical Equivalences:**
- Simplifying expressions
- Proving equivalences
- Converting to normal forms

**Resolution:**
- Automated theorem proving
- Large knowledge bases
- Systematic proof search

### Slide 49: Common Mistakes to Avoid
‚ùå **Confusing ‚Üí with ‚Üî**
- P ‚Üí Q does NOT mean Q ‚Üí P

‚ùå **Incorrect De Morgan's application**
- ¬¨(P ‚àß Q) is ¬¨P ‚à® ¬¨Q, NOT ¬¨P ‚àß ¬¨Q

‚ùå **Affirming the consequent**
- P ‚Üí Q, Q ‚ä¨ P (Invalid!)

‚ùå **Denying the antecedent**
- P ‚Üí Q, ¬¨P ‚ä¨ ¬¨Q (Invalid!)

‚úÖ **Always verify with truth tables if unsure!**

### Slide 50: Practice Recommendations
**For this week:**
1. Practice truth tables for complex formulas
2. Master CNF conversion
3. Work through resolution proofs
4. Study the Wumpus World example
5. Solve exercises in AIMA Chapter 7

**Homework Assignment:**
- Posted on LMS: [Forum Discussion](https://elearning.fda.edu.vn/mod/forum/)
- Due: Before next class
- Topics: Truth tables, equivalences, CNF, resolution

---

## üìö Part 11: Additional Resources

### Slide 51: Recommended Study Materials
**Textbook Readings:**
- AIMA Chapter 7: Logical Agents
- AIMA Chapter 8: First-Order Logic (preview)

**Online Resources:**
- [Propositional Logic Tutorial](https://www.youtube.com/watch?v=ONxr7v3HaKo&t=1894s)
- Logic calculators and proof checkers
- Practice problem sets

**Tools:**
- Truth table generators
- CNF converters
- SAT solvers (MiniSat, Z3)

### Slide 52: Preview - Next Lecture
**First-Order Logic (FOL):**
- Objects and relations
- Predicates and functions
- Universal (‚àÄ) and existential (‚àÉ) quantifiers
- Unification and resolution in FOL
- Knowledge representation with FOL

**Why FOL?**
- More expressive than propositional logic
- Can represent complex relationships
- Foundation for knowledge representation
- Used in databases (Datalog), planning, NLP

### Slide 53: Questions?
**Discussion Topics:**
- Any confusion about truth tables?
- Difficulty with CNF conversion?
- Questions about resolution algorithm?
- Real-world applications you're curious about?

**Office Hours:**
- Dr. Trong-Nghia Nguyen: nghiant@neu.edu.vn
- Dr. Nguyen Thi Kim Ngan: ngannguyen@neu.edu.vn

**Next Class:**
- Practical exercises on Propositional Logic
- Hands-on resolution proof exercises
- Introduction to First-Order Logic

---

## üé® Visual Aids and Diagrams

### Recommended Visuals for Slides:

1. **Knowledge-Based Agent Architecture**
   - Flow diagram: Sensors ‚Üí KB ‚Üí Inference ‚Üí Actions

2. **Truth Table Animations**
   - Progressive building of complex truth tables
   - Color-coding for TRUE (green) and FALSE (red)

3. **CNF Conversion Process**
   - Step-by-step tree diagram
   - Before/after comparisons

4. **Resolution Proof Tree**
   - Visual representation of resolution steps
   - Highlight contradictions

5. **Wumpus World Map**
   - Grid with symbols for pits, Wumpus, gold
   - Agent's path and inferences

6. **Logical Connectives Venn Diagrams**
   - Visual representation of AND, OR operations
   - Overlapping regions for understanding

---

## üíª Python Code Examples

### Code Example 1: Truth Table Generator
```python
def truth_table(formula, variables):
    """Generate truth table for a propositional formula"""
    import itertools
    
    print("Truth Table for:", formula)
    print("|", " | ".join(variables), "|", formula, "|")
    print("|" + "---|" * (len(variables) + 1))
    
    for values in itertools.product([True, False], repeat=len(variables)):
        env = dict(zip(variables, values))
        result = eval(formula.replace('‚Üí', '<=').replace('‚àß', 'and')
                            .replace('‚à®', 'or').replace('¬¨', 'not '), env)
        row = "|".join(["T" if v else "F" for v in values])
        print(f"| {row} | {'T' if result else 'F'} |")

# Example usage
truth_table("(P and Q) or (not P and R)", ['P', 'Q', 'R'])
```

### Code Example 2: Simple Resolution Prover
```python
class Clause:
    def __init__(self, literals):
        self.literals = frozenset(literals)
    
    def resolve(self, other):
        """Resolve two clauses"""
        resolvents = []
        for lit1 in self.literals:
            for lit2 in other.literals:
                if lit1 == f"¬¨{lit2}" or f"¬¨{lit1}" == lit2:
                    # Found complementary literals
                    new_clause = (self.literals - {lit1}) | (other.literals - {lit2})
                    if len(new_clause) == 0:
                        return [Clause(set())]  # Empty clause
                    resolvents.append(Clause(new_clause))
        return resolvents

def pl_resolution(kb, query):
    """Resolution-based theorem prover"""
    clauses = kb + [negate(query)]
    
    while True:
        new = set()
        pairs = [(clauses[i], clauses[j]) 
                 for i in range(len(clauses)) 
                 for j in range(i+1, len(clauses))]
        
        for c1, c2 in pairs:
            resolvents = c1.resolve(c2)
            if Clause(set()) in resolvents:
                return True  # Proved
            new.update(resolvents)
        
        if new.issubset(clauses):
            return False  # Cannot prove
        
        clauses.extend(new)
```

---

## üéØ Learning Assessment

### Quiz Questions (for student self-assessment):

1. **What is the truth value of (False ‚Üí True)?**
   - Answer: True

2. **Simplify: ¬¨(P ‚à® ¬¨Q)**
   - Answer: ¬¨P ‚àß Q

3. **Is (P ‚Üí Q) ‚â° (Q ‚Üí P)?**
   - Answer: No (counterexample: P=T, Q=F)

4. **Convert to CNF: (P ‚àß Q) ‚Üí R**
   - Answer: (¬¨P ‚à® ¬¨Q ‚à® R)

5. **What inference rule is this: P‚ÜíQ, Q‚ÜíR, therefore P‚ÜíR?**
   - Answer: Hypothetical syllogism (chain rule)

---

## üìñ Bilingual Terminology Reference

### English - Vietnamese Glossary:
- Proposition = M·ªánh ƒë·ªÅ
- Atomic proposition = M·ªánh ƒë·ªÅ ƒë∆°n
- Compound proposition = M·ªánh ƒë·ªÅ ph·ª©c h·ª£p
- Negation = Ph·ªß ƒë·ªãnh
- Conjunction = H·ªôi
- Disjunction = Tuy·ªÉn
- Implication = K√©o theo
- Biconditional = T∆∞∆°ng ƒë∆∞∆°ng
- Premise = Ti·ªÅn ƒë·ªÅ / Gi·∫£ thi·∫øt
- Conclusion = K·∫øt lu·∫≠n
- Inference = Suy di·ªÖn / Suy lu·∫≠n
- Entailment = K√©o theo logic
- Tautology = H·∫±ng ƒë√∫ng
- Contradiction = H·∫±ng sai / M√¢u thu·∫´n
- Model = M√¥ h√¨nh
- Satisfiable = Th·ªèa m√£n ƒë∆∞·ª£c
- Valid = H·ª£p l·ªá
- Sound = ƒê√∫ng ƒë·∫Øn
- Complete = ƒê·∫ßy ƒë·ªß

---

## üîó References and Citations

1. Russell, S. & Norvig, P. (2020). *Artificial Intelligence: A Modern Approach* (4th ed.). Pearson. Chapter 7: Logical Agents.

2. YouTube Tutorial: [Propositional Logic](https://www.youtube.com/watch?v=ONxr7v3HaKo&t=1894s) - Comprehensive introduction with examples.

3. Ben-Ari, M. (2012). *Mathematical Logic for Computer Science* (3rd ed.). Springer.

4. Huth, M., & Ryan, M. (2004). *Logic in Computer Science: Modelling and Reasoning about Systems*. Cambridge University Press.

5. Smullyan, R. M. (1995). *First-Order Logic*. Dover Publications.

---

**End of Lecture Content Guide**

*This document provides comprehensive content for creating lecture slides on Propositional Logic. Adjust the depth and pacing based on your students' background and available time.*

**Prepared by:** Dr. Trong-Nghia Nguyen  
**Course:** Introduction to Artificial Intelligence  
**National Economics University**

